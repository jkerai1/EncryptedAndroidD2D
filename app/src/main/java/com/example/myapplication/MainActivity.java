package com.example.myapplication;
import android.Manifest;
import android.annotation.SuppressLint;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.IntentFilter;
import android.net.wifi.WifiManager;
import androidx.annotation.NonNull;
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;
import androidx.security.crypto.MasterKeys;
import android.net.wifi.p2p.WifiP2pConfig;
import android.net.wifi.p2p.WifiP2pDevice;
import android.net.wifi.p2p.WifiP2pDeviceList;
import android.net.wifi.p2p.WifiP2pInfo;
import android.net.wifi.p2p.WifiP2pManager;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.security.keystore.KeyGenParameterSpec;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import com.gun0912.tedpermission.PermissionListener;
import com.gun0912.tedpermission.TedPermission;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.NetworkInterface;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.UUID;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

public class MainActivity extends AppCompatActivity {

    //UI elements
    Button btnDiscover, btnSend;
    ListView listView;
    TextView connectionStatus;
    ListView MessageHistory;
    EditText writeMsg;

    ArrayList<String> message_history = new ArrayList<String>();
    ArrayAdapter myAdapter1;

    WifiManager wifiManager;
    WifiP2pManager mManager;
    WifiP2pManager.Channel mChannel;

    BroadcastReceiver mReceiver;
    IntentFilter mIntentFilter;

    List<WifiP2pDevice> peers = new ArrayList<WifiP2pDevice>();
    String[] deviceNameArray;
    WifiP2pDevice[] deviceArray;
    static final int MESSAGE_READ = 1;

    ServerClass serverClass;
    ClientClass clientClass;
    SendReceive sendReceive;

    private Cipher cipher,decipher;
    private SecretKeySpec secretKeySpec;
    private byte encryptionKey[] = {9,115,51,86,105,4,-31,-23,-68,88,17,20,3,-105,119,53} ; //generate key using my proto, here is just a dummy key


    public Boolean StartofConversation = true;
    //boolean isServer =false;
    //public  static final int RequestPermissionCode  = 1 ;

   // TelephonyManager telephonyManager;
   // telephonyManager = getSystemService(this.TELEPHONY_SERVICE);
    //telephonyManager = (TelephonyManager) this.getSystemService(Context.TELEPHONY_SERVICE);
    //String imeiNumber = telephonyManager.getDeviceId();
    //Generate Keys, Ideally this would be pregenerated by CA. https://developer.android.com/topic/security/data https://developer.android.com/training/articles/keystore

    //Android Keystore system lets you store cryptographic keys in a container to make it more difficult to extract from the device
    KeyGenParameterSpec keyGenParameterSpec = MasterKeys.AES256_GCM_SPEC;
    String masterKeyAlias;

    {
        try {
            masterKeyAlias = MasterKeys.getOrCreate(keyGenParameterSpec);
        } catch (GeneralSecurityException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initialWork();
        exqListener();
        try {
            cipher = Cipher.getInstance("AES");
            decipher = Cipher.getInstance("AES");
            secretKeySpec = new SecretKeySpec(encryptionKey, "AES");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }
    }

    Handler handler = new Handler(new Handler.Callback() {

        @Override
        public boolean handleMessage(Message message) {
            switch (message.what) {
                case MESSAGE_READ:

                    byte[] readBuff = (byte[]) message.obj;
                    String tempMsg = new String(readBuff, 0, message.arg1);

                    message_history.add("[THEM  " + TimeStamp() +"]  " + AESDecryptionMethod(tempMsg));
                    myAdapter1.notifyDataSetChanged(); //refresh
                    break;
            }
            return true;
        }
    });

    @Override
    protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        //setContentView(R.layout.activity_main);
        //initialWork();
        //exqListener();
        peers.clear();
    }

    private void exqListener() {
        btnDiscover.setOnClickListener(new View.OnClickListener() {
            @SuppressLint("MissingPermission")
            @Override
            public void onClick(View view) {

                EnableRuntimePermission(); //ask user for permission to use Wi-Fi & Location
                mManager.discoverPeers(mChannel, new WifiP2pManager.ActionListener() {  //added permission to the manifest
                    @Override
                    public void onSuccess() {
                        connectionStatus.setText("Discovery Started");
                    }
                    @Override
                    public void onFailure(int i) {
                        connectionStatus.setText("Discovery Failed, Check Location is ON");
                    }
                });
            }
        });

        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {    //permissions defined in manifest
            @SuppressLint("MissingPermission")
            @Override
            public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
                final WifiP2pDevice device = deviceArray[i];
                WifiP2pConfig config = new WifiP2pConfig();
                config.deviceAddress = device.deviceAddress;

                mManager.connect(mChannel, config, new WifiP2pManager.ActionListener() {
                    @SuppressLint("MissingPermission")
                    @Override
                    public void onSuccess() {
                        Toast.makeText(getApplicationContext(), "Connected to " + device.deviceName, Toast.LENGTH_SHORT).show();
                    }
                    @SuppressLint("MissingPermission")
                    @Override
                    public void onFailure(int i) {
                        Toast.makeText(getApplicationContext(), "Not connected", Toast.LENGTH_SHORT).show();
                    }
                });
            }
        });

        btnSend.setOnClickListener(new View.OnClickListener() {
            @RequiresApi(api = Build.VERSION_CODES.O)
            @Override
            public void onClick(View v) {
                String msg = writeMsg.getText().toString();//  redundant: byte[] bytes = msg.getBytes();

                if (StartofConversation) {

                    //GET pub key

                    sendtask t2 = new sendtask(AESEncryptionMethod(GetMacAddress() + "   " + GenerateNonce())); ///Encrypt with Recipient pub key


                    t2.execute();
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    //encryptionKey[]         //secretKey = new established key that will be used to send msgs
                    //secretKeySpec = new SecretKeySpec(encryptionKey, "AES");
                    StartofConversation = false; //set this boolean to false
                }

                    sendtask t1=new sendtask(AESEncryptionMethod(msg)); //create new thread for sending the message
                    t1.execute(); //start new thread
                    message_history.add("[YOU  " + TimeStamp() +"]  " + msg); //Update message history
                }


        //btnSend.setOnClickListener(new View.OnClickListener() {
          //  @Override
            //public void onClick(View view) {
              //  String msg = writeMsg.getText().toString();
                //sendReceive.write(msg.getBytes());
                //byte[] bytes = msg.getBytes();
               //btnSend.setVisibility(View.INVISIBLE);
                //if(connectionStatus.equals("Host")) {
                  //  write(bytes);
                //} else {
                  //  write(bytes);
                //}

                //sendReceive.write(msg.getBytes());
            //}
        });
    }

    private void initialWork() {
        // Read in UI by ID defined in the XML
        btnDiscover = (Button) findViewById(R.id.discover);
        btnSend = (Button) findViewById(R.id.sendButton);
        listView = (ListView) findViewById(R.id.peerListView);
        MessageHistory = findViewById(R.id.MessageHistory);
        connectionStatus = (TextView) findViewById(R.id.connectionStatus);
        writeMsg = findViewById(R.id.writeMsg);

        myAdapter1 = new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,message_history);
        MessageHistory.setAdapter(myAdapter1); //in order to use listviews in android you need an adapter

        ///wifi manager
        wifiManager = (WifiManager) getApplicationContext().getSystemService(Context.WIFI_SERVICE);// initialise the wifi manager
        mManager = (WifiP2pManager) getSystemService(Context.WIFI_P2P_SERVICE);
        mChannel = mManager.initialize(this, getMainLooper(), null);
        mReceiver = new WiFiDirectBroadcastReceiver(mManager, mChannel, this);


        //Intents
        //An intent is an abstract description of an operation to be performed. It can be used with Context#startActivity(Intent)
        // to launch an Activity, broadcastIntent to send it to any interested BroadcastReceiver components, and Context.startService(Intent) or Context.bindService(Intent, ServiceConnection, int)
        // to communicate with a background Service.
        //An Intent provides a facility for performing late runtime binding between the code in different applications.
        // Its most significant use is in the launching of activities, where it can be thought of as the glue between activities.
        // It is basically a passive data structure holding an abstract description of an action to be performed.

        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
    }

    WifiP2pManager.PeerListListener peerListListener = new WifiP2pManager.PeerListListener() {
        @Override
        public void onPeersAvailable(WifiP2pDeviceList peerlist) {

            if (!peerlist.getDeviceList().equals(peers)) {
                peers.clear(); //remove old peers
                peers.addAll(peerlist.getDeviceList()); //get new peer list
                deviceNameArray = new String[peerlist.getDeviceList().size()];
                deviceArray = new WifiP2pDevice[peerlist.getDeviceList().size()];
                int index = 0;

                for (WifiP2pDevice device : peerlist.getDeviceList()) {
                    deviceNameArray[index] = device.deviceName;
                    deviceArray[index] = device;
                    index++;
                }
                ArrayAdapter<String> adapter = new ArrayAdapter<String>(getApplicationContext(), android.R.layout.simple_list_item_1, deviceNameArray);
                listView.setAdapter(adapter);
            }
            if (peers.size() == 0) {
                Toast.makeText(getApplicationContext(), "No Devices Found ", Toast.LENGTH_SHORT).show();  // tell the user no devices where found,
                                                                                                                // Toast is the white popup that automatically closes at the bottom of the screen
                return;
            }
        }
    };

    WifiP2pManager.ConnectionInfoListener connectionInfoListener = new WifiP2pManager.ConnectionInfoListener() {
        @Override
        public void onConnectionInfoAvailable(WifiP2pInfo wifiP2pInfo) {
            final InetAddress groupOwnerAddress = wifiP2pInfo.groupOwnerAddress;
            if (wifiP2pInfo.groupFormed && wifiP2pInfo.isGroupOwner) {
                connectionStatus.setText("Host");
                serverClass = new ServerClass();// isServer = true;
                serverClass.start(); //start thread

            } else if (wifiP2pInfo.groupFormed) {
                connectionStatus.setText("Client");
                clientClass = new ClientClass(groupOwnerAddress);//isServer =false;
                clientClass.start(); //start thread
            }
            String currentTime;
            String currentDate = new SimpleDateFormat("dd-MM-yyyy  ", Locale.getDefault()).format(new Date());
            currentTime = TimeStamp();
            message_history.add("Conversation Start  " + currentDate + currentTime);
            btnSend.setVisibility(View.VISIBLE);
        }
    };

    @Override
    protected void onPause() { //code to be run if user leaves the app
        super.onPause();
        unregisterReceiver(mReceiver);
    }

    @Override
    protected void onResume() {
        super.onResume();
        registerReceiver(mReceiver, mIntentFilter);
    }

    @Override
    protected void onDestroy() {   //code to be run before activity is destroyed
        connectionStatus.setText("Off");
        btnSend.setVisibility(View.GONE); //hide send button this is to prevent user sending anything
        super.onDestroy();
    }

    public class ServerClass extends Thread {

        Socket socket;
        ServerSocket serverSocket;

        @Override
        public void run() {
            try {
                serverSocket = new ServerSocket(8888); //arbitrarily chosen socket
                socket = serverSocket.accept();
                sendReceive = new SendReceive(socket);
                sendReceive.start(); //start thread
            } catch (IOException e) {
                e.printStackTrace();
                try {
                    serverSocket.close(); //force close socket on error
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }//  super.run();
        }

    }

    public class ClientClass extends Thread {
        Socket socket;
        String hostAdd;

        public ClientClass(InetAddress hostAddress) {
            hostAdd = hostAddress.getHostAddress();
            socket = new Socket(); }

        @Override
        public void run() {
            //while (!Thread.currentThread().isInterrupted()) {
                try {
                    socket.connect(new InetSocketAddress(hostAdd, 8888), 500); //Please try to find the solution how to close socket while disconnecting the device.
                    sendReceive = new SendReceive(socket);
                    sendReceive.start();
                } catch (IOException e) {
                    try {
                        socket.close(); //force close socket in case of error
                    } catch (IOException ex) {
                        ex.printStackTrace();
                    }
                    e.printStackTrace();
                }// super.run();
            }
        //}
    }

    private class SendReceive extends Thread {
        private Socket socket;
        private InputStream inputStream;
        private OutputStream outputStream;


        public SendReceive(Socket skt) {
            socket = skt;
            try {
                inputStream = socket.getInputStream();
                outputStream = socket.getOutputStream();
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } catch (IOException e) {
                e.printStackTrace();}
        }

        @Override
        public void run() {
            byte[] buffer = new byte[1024];
            int bytes;
            while (socket != null) {
                try {
                    bytes = inputStream.read(buffer);
                    if (bytes > 0) { //i.e if there is a message
                        handler.obtainMessage(MESSAGE_READ, bytes, -1, buffer).sendToTarget();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        public void write(final byte[] bytes)
        {
            new Thread(new Runnable(){

                @Override
                public void run()
                {
                    try
                    {
                        outputStream.write(bytes);
                    }
                    catch (IOException e)
                    {e.printStackTrace();}
                }}).start();
        }
    }

    @SuppressLint("StaticFieldLeak")
    public class sendtask extends AsyncTask<Void, Void, Void> {
        String message;

        sendtask(String msg) {
            message=(msg);
        }

        @RequiresApi(api = Build.VERSION_CODES.O)
        @Override
        protected Void doInBackground(Void... arg0) {
           sendReceive.write((message).getBytes());
            return null;
        }
        @Override
        protected void onPostExecute(Void result) {
            super.onPostExecute(result);
        }
    }

    public void EnableRuntimePermission(){
        String[] perms ={Manifest.permission.ACCESS_FINE_LOCATION,Manifest.permission.READ_PHONE_STATE}; // Permissions I want to ask
        PermissionListener permissionListener = new PermissionListener() {
            @Override
            public void onPermissionGranted() {
              //  Toast.makeText(MainActivity.this,"Permissions Granted", Toast.LENGTH_SHORT).show();
            }
            @Override
            public void onPermissionDenied(List<String> deniedPermissions) {
                Toast.makeText(MainActivity.this,"Required Location permission for D2D", Toast.LENGTH_LONG).show();
            }
        };
        TedPermission.with(MainActivity.this)
                .setPermissionListener(permissionListener)
                .setPermissions(perms)
                .check();
    }

    private static String TimeStamp() {
        //String currentDate = new SimpleDateFormat("dd-MM-yyyy  ", Locale.getDefault()).format(new Date());
        String currentTime = new SimpleDateFormat("HH:mm", Locale.getDefault()).format(new Date());
        return currentTime;
    }

    @RequiresApi(api = Build.VERSION_CODES.O)
    public static String GenerateNonce(){
        SecureRandom rnd = new SecureRandom();
        int byteLength = 32;
        byte[] token = new byte[byteLength];
        rnd.nextBytes(token);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(token);
    }

    //public static String generateNonce() {
      //  String uuid = UUID.randomUUID().toString().replaceAll("-", ""); //String uuid = UUID.randomUUID().toString();
        //return uuid;
    //}

    public static String GetMacAddress(){ //This will serve as AID
        String stringMac ="";
        try {
            List<NetworkInterface> networkInterfaceList = Collections.list(NetworkInterface.getNetworkInterfaces()); //read in list of network interfaces

            for (NetworkInterface networkInterface:networkInterfaceList){
                if(networkInterface.getName().equalsIgnoreCase("wlan0")){ //compares strings to see if equal, here we are looking for wlan0

                    for(int i=0; i<networkInterface.getHardwareAddress().length;i++){ //access each sub-part of mac address
                        String stringMacByte = Integer.toHexString( networkInterface.getHardwareAddress()[i] & 0xFF); //read back each byte in hex

                        if (stringMacByte.length() == 1){
                            stringMacByte = "0" + stringMacByte; //fill in 0s where length is 1
                        }
                        stringMac =stringMac + stringMacByte.toUpperCase() + ":"; //convert all to uppercase and add semicolons between each 2 hex pair
                    }
                    break;
                }
            }
        } catch (SocketException e) {
            e.printStackTrace();
        }
        return stringMac.substring(0,stringMac.length()-1); //strip last semi colon off
    }
    private String AESEncryptionMethod(String string){

        byte[] stringByte = string.getBytes();
        byte[] encryptedByte = new byte[stringByte.length];
        try {
            cipher.init(Cipher.ENCRYPT_MODE,secretKeySpec);
            encryptedByte = cipher.doFinal(stringByte);
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }
        String returnString = null;
        try {
            returnString = new String(encryptedByte,"ISO-8859-1");//specifying what character set to use
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return returnString;
    }

    private String AESDecryptionMethod(String string) {
        String decryptedString = null;
        try {
            byte[] EncryptedByte = string.getBytes("ISO-8859-1"); //specifying what character set to use
            decryptedString = string;
            byte[] decryption;
            decipher.init(cipher.DECRYPT_MODE, secretKeySpec); // init decrypt mode with key
            decryption = decipher.doFinal(EncryptedByte); // pass encrypted msg to algorithm
            decryptedString = new String(decryption); //Plaintext

        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return decryptedString;
    }
}